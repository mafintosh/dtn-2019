<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
  <title>Big</title>
  <link href="big.css" rel="stylesheet" type="text/css" />
  <script src="big.js"></script>
  <style>
    .one {
      white-space: nowrap;
    }

    #small {
      transition: font-size 1s ease;
    }
  </style>
</head>
<body class="light">
  <div>
    <em>DTN</em> <i>2019</i>
  </div>
  <div>
    @mafintosh
  </div>
  <div>
    Dat protocol lead
  </div>
  <div>
    (eco system drawing)
  </div>
  <div>
    Hyper<em>‚òÜ</em>
  </div>
  <div>
    Core Team
  </div>
  <div>
    Hyper<em>core</em>
  </div>
  <div>
    HSM support
  </div>
  <div>
    Audit nodes
  </div>
  <div>
    Updated wire protocol*
  </div>
  <div>
    Hyper<em>drive</em>
  </div>
  <div>
    Hyperdrive is our file system abstraction
  </div>
  <div>
    Implements a distributed POSIX* FS, focused on real time updates
  </div>
  <div>
    Uses a 2 hypercore design
  </div>
  <div>
    <span class="one">1 metadata hypercore</span><br>
    <span class="one">1 content hypercore</span>
  </div>
  <div>
    Metadata hypercore:

<pre>
0: [header with a link to the content feed]
1: name: foo.txt, contentPtr: 0, blocks: 10, [lookup-tree-index]
2: name: bar.txt, contentPtr: 10, blocks: 1, [lookup-tree-index]
...
</pre>
  </div>
  <div>
    lookup-tree-index is an embedded data structure that allows distributed random access
  </div>
  <div>
    <span class="one">Upcoming version: Hyperdrive 10</span>
  </div>
  <div>
    <span class="one">Andrew Osheroff (andrewosh)</span>
    <div class="one">Mathias Buus (mafintosh)</div>
  </div>
  <div>
    <span class="one">Andrew Osheroff (andrewosh)</span>
    <div class="one" id="small">Mathias Buus (mafintosh)</div>
    <script>
      document.addEventListener('keyup', function () {
        if (document.querySelector('#small').parentElement.parentElement.style.display === 'none') {
          document.querySelector('#small').style.fontSize = 'inherit'
        } else {
          document.querySelector('#small').style.fontSize = '20px'
        }
      })
      console.log('hi')
    </script>
  </div>
  <div>
    <em>Problem</em>:<br> Writing tons of files to a folder slows down lookups
  </div>
  <div>
    The current tree index does a linear scan of a folder to find an entry
  </div>
  <div>
    <em>Solution</em>:<br> In Hyperdrive 10 we moved to a hash trie (HAMT)
  </div>
  <div>
    Find any entry in log4(metadata.length) lookups
  </div>
  <div>
    HAMT crash course. We want to support:

<pre>
drive.get('/file/path/somewhere') -> entry
</pre>
  </div>
  <div>
    <span class="one">We only append only storage, so we can do:</span>

<pre>
seq = core.append(data)
data = core.get(seq)
</pre>
  </div>
  <div>
<pre>
append({ name: '/file/path/somewhere' })
</pre>
  </div>
  <div>
<pre>
trie_path('/file/path/somewhere') ->
  base4_hash('file') + base4_hash('path') + base4_hash('somewhere')
</pre>
  </div>
  <div>
<pre>
trie_path('/file/path/somewhere') ->
  '30103132' + '13200133' + '22330001'                            <span style="color: transparent;">.</span>
</pre>
  </div>
  <div>
<pre>
trie_path('/file/path/somewhere') ->
  '301031321320013322330001'                                      <span style="color: transparent;">.</span>
</pre>
  </div>
  <div>
    Write pointers to each latest core entry that shares a prefix off your trie path
  </div>
  <div>
<pre>
#42                <span style="color: transparent;">.</span>

3
0
1
0
3
1
3
2
1
3
2
0
0
1
3
3
2
2
3
3
0
0
0
1
</pre>
  </div>
  <div>
<pre>
#42  #39           <span style="color: transparent;">.</span>

3    3
0    0
1    1
0    0
3    3
1    2
3    0
2    0
1    3
3    3
2    2
0    0
0    1
1    2
3    2
3    0
2    3
2    1
3    1
3    3
0    3
0    0
0    1
1    0
</pre>
  </div>
  <div>
<pre>
#42  #39           <span style="color: transparent;">.</span>

<span style="color: red;">3    3</span>
<span style="color: red;">0    0</span>
<span style="color: red;">1    1</span>
<span style="color: red;">0    0</span>
<span style="color: red;">3    3</span>
1    2
3    0
2    0
1    3
3    3
2    2
0    0
0    1
1    2
3    2
3    0
2    3
2    1
3    1
3    3
0    3
0    0
0    1
1    0
</pre>
  </div>
  <div>
<pre>
#42                <span style="color: transparent;">.</span>

3
0
1
0
3 --+
1   2 (#39)
3
2
1
3
2
0
0
1
3
3
2
2
3
3
0
0
0
1
</pre>
  </div>
  <div>
<pre>
#42                <span style="color: transparent;">.</span>

3 --+
0   1 (#35)
1
0
3 --+
1   2 (#39)
3
2
1
3
2
0
0
1
3
3
2
2
3
3
0
0
0
1
</pre>
  </div>
  <div>
<pre>
#42                <span style="color: transparent;">.</span>

3 --+
0   1 (#35)
1   (max 3 branches)
0
3 --+
1   2 (#39)
3
2
1
3
2
0
0
1
3
3
2
2
3
3
0
0
0
1
</pre>
  </div>
  <div>
    The <span class="one">lookup-tree-index</span> contains only the branch pointers
  </div>
  <div>
    lookup-tree-index:
<pre>
[
  [ 1, 1, 35 ] // branches at index 1, into 1 (seq #35)
  [ 4, 2, 39 ] // branches at index 4, into 2 (seq #39)
]
</pre>
  </div>
  <div>
    To find a file path do:

<pre>
  target_trie_path = trie_path('/path/we/want')
  head = core.get(core.length - 1)
</pre>
  </div>
  <div>
<pre>
lookup (head) ->
  prefix = calc_shared_prefix(head.trie_path, target_trie_path)

  if (prefix == head.trie_path)
    return head

  if (is_branch(head, prefix))
    return lookup(get_branch_node(head, prefix))

  return 404
</pre>
  </div>
  <div>
    Status:<br>
    Fully working, tested, and implemented üòé
  </div>
  <div>
    Problem: Collaborating with and consuming multiple Hyperdrives is hard
  </div>
  <div>
    (Multiwriter)
  </div>
  <div>
    Solution: Hyperdrive 10 adds mount support
  </div>
  <div>
    Mounts mean you can mount other hyperdrives inside your own hyperdrive
  </div>
  <div>
<pre>
drive.mount('/some/path', 'deadbeef')
</pre>
  </div>
  <div>
    Mounts are persisted inside the metadata in a scalable way
  </div>
  <div>
    Mounted drives can symlink files outside their own drive*
  </div>
  <div>
    Much simpler and more flexible design that our previous endevours
  </div>
  <div>
    Mount points are simply stored inside the hash trie
  </div>
  <div>
<pre>
drive.mount('/some/path', 'deadbeef')
drive.get('/some/path/and/stuff')

1. Does a lookup in the local trie.
2. The last node has a mount flag set.
3. Loads the mounted drive and performs
   a .get('/and/stuff') on the mount
</pre>
  </div>
  <div>
    Status:<br>
    ~Working, implemented, but needs testing üëç
  </div>
  <div>
    We plan on adding support for "overlapping" mounts as well, but in later releases.
  </div>
  <div>
    Inodes
  </div>
  <div>
    FUSE
  </div>
  <div>
    Follow v10 dev ->
    <a href="https://github.com/mafintosh/hyperdrive/pull/233">https://github.com/mafintosh/hyperdrive/pull/233</a>
  </div>
  <div>
    Hyper<em>swarm</em>
  </div>
  <div>
    P2P first DHT
  </div>
  <div>
    Tying it all together
  </div>
</body>
</html>
